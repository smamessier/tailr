"""Visualization utils"""

import torch
import torch.nn as nn
import torch.nn.functional as F
import logging
import numpy as np
import plotly.graph_objects as go
import plotly.express as px

from plotly.subplots import make_subplots
from tensorboard import program
from typing import List, Tuple
from scipy.signal import savgol_filter


def save_fig(array, x_vals=None, file_path='my_fig.pdf', legend=None, x_label=None, y_label=None, title=None):
    if x_vals is None:
        x_vals = np.arange(len(array))

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=x_vals, y=array,
                             mode='lines', name=legend))

    fig.update_layout(title=title, xaxis_title=x_label, yaxis_title=y_label)

    fig.write_html(file_path)


def save_img_from_tensor(tensor, file_path="my_fig.pdf", title=None):
    np_img = tensor.cpu().detach().numpy()
    np_img = np.squeeze(np_img)
    fig = px.imshow(np_img, color_continuous_scale='gray')

    fig.write_html(file_path)


def save_loss_info(log_ps, kl_ys, kl_zs, losses, path):
    """Save figures of the loss terms to a given path

    Args:
        log_ps: history of the log-likelihood, List[int]
        kl_ys: history of the cluster KL, List[int]
        kl_zs: history of the latent KL, List[int]
        losses: history of the loss, List[int]
        path: path for saving the figs, str
    """
    save_fig(log_ps, file_path=f'{path}/tailr_gen_log_p.html',
             title='Log_prob for split-MNIST', x_label='Train Batches', y_label='Log p(x)')
    save_fig(kl_ys, file_path=f'{path}/tailr_gen_kl_y.html',
             title='KL for cluster distribution for split-MNIST', x_label='Train Batches', y_label='KL Y')
    save_fig(kl_zs, file_path=f'{path}/tailr_gen_kl_z.html',
             title='KL for latent distribution for split-MNIST', x_label='Train Batches', y_label='KL Z')
    save_fig(losses, file_path=f'{path}/tailr_gen_losses.html',
             title='ELBO for split-MNIST', x_label='Train Batches', y_label='ELBO')


def save_single_cluster_generation_img(model, path, name, cluster_idx):
    """Save distribution probs (in the form of image) generated by one cluster

    Args:
        model: The model used to generated images, TAILR
        path: path for saving the images, str
        name: specific name for the group of images, str
        cluster_idx: cluster used for image generation, int
    """
    if cluster_idx > model.n_y_active:
        raise ValueError('The cluster you chose is not active yet')

    some_generation_sample, some_generation_dist = model.generate_data_single_cluster(
        cluster_idx)
    save_img_from_tensor(
        some_generation_dist.probs.cpu().detach(), file_path=f'{path}/generation_probs_cluster{cluster_idx}_{name}.html', title=f'Prob dist Generation of cluster {cluster_idx}')


def save_single_cluster_multi_generations(model, path, name, cluster_idx, img_per_cluster=50):
    """Save generated distribution probabilities of a singe cluster

    Args:
        model: The model used to generated images, TAILR
        path: path for saving the images, str
        name: specific name for the group of images, str
        cluster_idx: cluster used for image generation, int
        img_per_cluster: number of generation needed, int
    """

    buffer = []
    for _ in range(img_per_cluster):
        some_generation_sample, some_generation_dist = model.generate_data_single_cluster(
            cluster_idx)
        buffer.append(some_generation_dist.probs.cpu().detach())

    save_buffer_images(buffer, path, f'{name}_cluster{cluster_idx}')


def save_buffer_images(buffer, path, name, row_size=10):
    """Saves images of a given buffer in a matrix shape

    Args:
        buffer: list of tensors, List[torch.Tensor]
        path: path to save the resulting figure to, str
        name: name used for the image file, str
        row_size: number of images to fit in a single row
    """
    fig = make_subplots(
        rows=len(buffer) // row_size,
        cols=row_size,
        print_grid=False,
        horizontal_spacing=0.06 / (len(buffer) // row_size),
        vertical_spacing=0.05 / row_size,
    )

    for i, tensor in enumerate(buffer):
        fig.add_trace(
            go.Heatmap(
                z=tensor.detach().cpu().squeeze().T.rot90(k=1, dims=[0, 1]),
                colorscale='Greys',
                reversescale=True,
                showscale=False,
            ),
            (i // row_size) + 1,
            (i % row_size) + 1,
        )

    fig.update_xaxes(showticklabels=False)
    fig.update_yaxes(showticklabels=False)

    fig.write_html(f'{path}/{name}.html')


def save_all_clusters_multi_generations(model, path, name, img_per_cluster=50):
    """Save distribution (in the form of images) generated by the clusters

    Args:
        model: The model used to generated images, TAILR
        path: path for saving the images, str
        name: specific name for the group of images, str
        img_per_cluster: number of generation needed, int
    """
    for y in range(model.n_y_active):
        save_single_cluster_multi_generations(
            model, path, name, y, img_per_cluster=img_per_cluster)


def save_all_cluster_generation_img(model, path, name):
    """Save image generated by the clusters

    Args:
        model: The model used to generated images, TAILR
        path: path for saving the images, str
        name: specific name for the group of images, str
    """
    for y in range(model.n_y_active):
        save_single_cluster_generation_img(model, path, name, y)


def save_cluster_evolution(cluster_scores, path, name, title, x_label='', y_label='', n_y_active=None, smoothing_window=501, smoothing_degree=4):
    """Save graph showing evolution on the cluster scores 

    Args:
        cluster_scores: Buffer containing the cluster scores over time, List[torch.Tensor]
        path: path name for saving graph, str
        name: name of the file for the graph, str
    """
    if not x_label or not y_label:
        print(f'Hey, you should try to name your axis for readability\'s sake')

    if n_y_active is None:
        n_y_active = cluster_scores[0].shape[0]

    x_vals = np.arange(len(cluster_scores))
    fig = go.Figure()
    for i in range(n_y_active):
        fig.add_trace(go.Scatter(x=x_vals, y=savgol_filter(cluster_scores[:, i], smoothing_window, smoothing_degree),
                                 mode='lines', name=f'score for cluster {i}'))

    fig.update_layout(title=title, xaxis_title=x_label, yaxis_title=y_label)

    fig.write_html(f'{path}/{name}_{smoothing_window}_{smoothing_degree}.html')
